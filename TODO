Main stable release blockers
----------------------------

* add strict/lazy/permissive success/failure in unix/mixed pipes

* decide what to do about reader for backslash escaping newlines

* alternate reader where bare things on the top level are assumed to be normal racket UNLESS there is an explicit start pipe.  This would give an option to have a repl *almost* the same as the default racket repl, except with an easy escape into shell-world.

* inspecting pipeline segments with correct compound member handling

* rash macros
** what does it mean to run with stdin in the background unless I have job control?
** maybe the default input port should be allowed to be some function that determines what input it gets based on things like whether it's in the background or not?

* $_ implicit argument on pipelines
** for unix ones, detect it, use compound member to turn the input into an empty port and use $_ as a shell argument.  This may require rethinking the eager evaluation of arg list members...

* <() >() redirection and substitution

* unix pipeline member arguments #:e>, #:as, #:how-to-determine-success etc
** success determination should allow a predicate on the return value OR a list of good statuses
** some sort of alias-like thing to set an alternative default for success, so eg. grep can use this alias-like thing to save writing #:success '(0 1)

* unix pipeline operator that has a higher level alias functionality like the old rash had
** actually, there should probably be both a unixy operator AND an object operator that recognize aliases - these aliases can basically just make the operator resolution recur.  So you could have =u= grep foo, where grep is an alias to =u= #:success (list 1) "grep" foo.  You could have this alias checking and recursive lookup on any pipeline type, so maybe several of them should have it.  But then again, if an alias just causes a recursive operator resolution... what is the difference between having an alias and having another operator?

* pipeline that acts as an object pipe unless the function part is undefined as syntax, in which case it acts as a unixy pipe instead.

* unix pipeline operator that does globbing

* initial input-port transformer to try to solve readline-port issues

* optional kw-args for rash macros that affect read tables, macros to define rash macros and rash-module-begin with different defaults for all options including read table options

* some level of macros above pipelines - eg for define forms, maybe loops, etc.

* a version of pipeline running/rash macros that doesn't have all the overhead (maybe one that doesn't allow unix-segments)

* timestamps in pipeline objects, so I can do time reporting like zsh

* review names -- pick good ones before doing any stable release

* make pipeline objects sync-able

* have lexically scoped defaults for all pipeline options, similar to how the implicit starter operator works
** for status options strict/lazy/permissive, etc


* add features to shell/pipeline from its todo to get to a stable release point




misc
----

* option-app -- needs better name (kw-check-app?), and should it be part of another package?  I think I want to use it in more packages...


About interactive shells
------------------------

* job control -- for an interactive shell, how should the shell capture references to the pipelines to do job control?

* discoverability
** the default prompt should help with discoverability -- maybe say the command to get help, look up docs, etc.  Something like «type HELP START» in LoE.
** how can interactive features be more discoverable than just being listed in the docs/tutorial?


Documentation
-------------

* API docs
* guide -- high level overview
** maybe split it into sections for people with different backgrounds - eg. racketeers vs people coming from bash who don't know racket.

